package main

import (
  "log"
  "os"
  "net/http"

  "github.com/go-swagger/go-swagger/spec"

  {{range .DefaultImports}}{{printf "%q" .}}
  {{end}}
  {{range $key, $value := .Imports}}{{$key}} {{ printf "%q" $value}}
  {{end}}
)

// This file was generated by the swagger tool.
// Make sure not to overwrite this file after you generated it because all your edits would be lost!
// It would only be overwritten if you explicitly specify --include-main for the generate all or support commands
//go:generate swagger generate server -t ../.. -A {{.AppName}}{{if .Principal}} --principal {{.Principal}}{{end}}

var swaggerJSON = json.RawMessage({{.SwaggerJSON}})

func main() {
  swaggerSpec, err := spec.New(swaggerJSON, "")
  if err != nil {
    log.Fatalln(err)
  }

  port := os.Getenv("PORT")
  if port == "" {
    port = "0"
  }

  host := os.Getenv("HOST")
  if host == "" {
    host = "localhost"
  }

  api := {{.Package}}.New{{.AppName}}API(swaggerSpec)
  configureAPI(api)

  listener, err := net.Listen("tcp", host + ":" + port)
	if err != nil {
		log.Fatalln(err)
	}

	fmt.Printf("serving {{.HumanAppName}} at http://%s\n", listener.Addr())

  if err := http.Serve(listener, api.Serve{{if .IncludeUI}}WithUI{{end}}()); err != nil {
    log.Fatalln(err)
  }
}

func configureAPI(api *{{.Package}}.{{.AppName}}API) {
  // configure the api here
  api.ServeError = errors.ServeError


  {{range .Consumes}}{{if .Implementation}}api.{{.ClassName}}Consumer = {{.Implementation}}()
  {{else}}api.{{.ClassName}}Consumer = httpkit.ConsumerFunc(func(r io.Reader, target interface{}) error {
    return errors.NotImplemented("{{.Name}} consumer has not yet been implemented")
  }){{end}}
  {{end}}
  {{range .Produces}}{{if .Implementation}}api.{{.ClassName}}Producer = {{.Implementation}}()
  {{else}}api.{{.ClassName}}Producer = httpkit.ProducerFunc(func(w io.Writer, data interface{}) error {
    return errors.NotImplemented("{{.Name}} producer has not yet been implemented")
  }){{end}}
  {{end}}
  {{range .SecurityDefinitions}}
  {{if .IsBasicAuth}}
  api.{{.ClassName}}Auth = func(user string, pass string) (*{{.Principal}}, error) {
    return nil, errors.NotImplemented("basic auth has not yet been implemented")
  }
  {{end}}{{if .IsAPIKeyAuth}}
  api.{{.ClassName}}Auth = func(token string) (*{{.Principal}}, error) {
    return nil, errors.NotImplemented("api key auth {{.Name}} from {{.Source}} has not yet been implemented")
  }
  {{end}}
  {{end}}
  {{range .Operations}}{{if .Package}}api.{{.ClassName}}Handler = {{.Package}}.{{.ClassName}}HandlerFunc(func({{if .Params}}params {{.Package}}.{{.ClassName}}Params{{end}}{{if and .Authorized .Params}}, {{end}}{{if .Authorized}}principal *{{.Principal}}{{end}}) ({{if .SuccessModel}}{{if .ReturnsComplexObject}}*{{end}}{{.SuccessModel}}, {{end}}error) {
    return {{if .SuccessModel}}{{.SuccessZero}}, {{end}}errors.NotImplemented("operation {{.Name}} has not yet been implemented")
  })
  {{else}}api.{{.ClassName}}Handler = {{.ClassName}}HandlerFunc(func({{if .Params}}params {{.ClassName}}Params{{end}}{{if and .Authorized .Params}}, {{end}}{{if .Authorized}}principal *{{.Principal}}{{end}}) ({{if .SuccessModel}}{{if .ReturnsComplexObject}}*{{end}}{{.SuccessModel}}, {{end}}error) {
    return {{if .SuccessModel}}{{.SuccessZero}}, {{end}}errors.NotImplemented("operation {{.Name}} has not yet been implemented")
  })
  {{end}}
  {{end}}
}
